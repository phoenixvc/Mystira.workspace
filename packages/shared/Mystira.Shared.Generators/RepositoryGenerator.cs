using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace Mystira.Shared.Generators;

/// <summary>
/// Source generator that creates repository implementations from interfaces
/// decorated with [GenerateRepository].
/// </summary>
[Generator]
public class RepositoryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attribute source
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GenerateRepositoryAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Find all interfaces with [GenerateRepository] attribute
        var interfaceDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateInterface(s),
                transform: static (ctx, _) => GetInterfaceForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndInterfaces = context.CompilationProvider.Combine(interfaceDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndInterfaces,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsCandidateInterface(SyntaxNode node)
    {
        return node is InterfaceDeclarationSyntax interfaceSyntax
            && interfaceSyntax.AttributeLists.Count > 0;
    }

    private static InterfaceDeclarationSyntax? GetInterfaceForGeneration(GeneratorSyntaxContext context)
    {
        var interfaceSyntax = (InterfaceDeclarationSyntax)context.Node;

        foreach (var attributeList in interfaceSyntax.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var name = attribute.Name.ToString();
                if (name == "GenerateRepository" || name == "GenerateRepositoryAttribute")
                {
                    return interfaceSyntax;
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<InterfaceDeclarationSyntax?> interfaces, SourceProductionContext context)
    {
        if (interfaces.IsDefaultOrEmpty)
            return;

        foreach (var interfaceSyntax in interfaces.Distinct())
        {
            if (interfaceSyntax is null)
                continue;

            var semanticModel = compilation.GetSemanticModel(interfaceSyntax.SyntaxTree);
            var interfaceSymbol = semanticModel.GetDeclaredSymbol(interfaceSyntax);

            if (interfaceSymbol is null)
                continue;

            var source = GenerateRepositoryImplementation(interfaceSymbol);
            var fileName = $"{interfaceSymbol.Name.TrimStart('I')}Generated.g.cs";
            context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateRepositoryImplementation(INamedTypeSymbol interfaceSymbol)
    {
        var interfaceName = interfaceSymbol.Name;
        var className = interfaceName.TrimStart('I') + "Generated";
        var namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();

        // Extract entity type from interface (assumes IRepository<TEntity> pattern)
        var entityType = "object";
        var keyType = "Guid";

        foreach (var baseInterface in interfaceSymbol.AllInterfaces)
        {
            if (baseInterface.Name == "IRepository" && baseInterface.TypeArguments.Length >= 1)
            {
                entityType = baseInterface.TypeArguments[0].ToDisplayString();
                if (baseInterface.TypeArguments.Length >= 2)
                {
                    keyType = baseInterface.TypeArguments[1].ToDisplayString();
                }
                break;
            }
        }

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Ardalis.Specification;");
        sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine("using Mystira.Shared.Data.Repositories;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Auto-generated repository implementation for {interfaceName}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public partial class {className} : RepositoryBase<{entityType}>, {interfaceName}");
        sb.AppendLine("{");
        sb.AppendLine($"    public {className}(DbContext context) : base(context)");
        sb.AppendLine("    {");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    // Add custom method implementations in a partial class file");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private const string AttributeSource = @"// <auto-generated/>
#nullable enable

namespace Mystira.Shared.Data;

/// <summary>
/// Marks an interface for automatic repository implementation generation.
/// The source generator will create a class that implements this interface
/// by inheriting from RepositoryBase&lt;TEntity&gt;.
/// </summary>
/// <example>
/// <code>
/// [GenerateRepository]
/// public interface IAccountRepository : IRepository&lt;Account&gt;
/// {
///     // Custom methods can be defined here
///     Task&lt;Account?&gt; GetByEmailAsync(string email, CancellationToken ct = default);
/// }
///
/// // Generator creates:
/// public partial class AccountRepositoryGenerated : RepositoryBase&lt;Account&gt;, IAccountRepository
/// {
///     public AccountRepositoryGenerated(DbContext context) : base(context) { }
/// }
///
/// // You can extend in a partial class:
/// public partial class AccountRepositoryGenerated
/// {
///     public async Task&lt;Account?&gt; GetByEmailAsync(string email, CancellationToken ct = default)
///     {
///         return await DbSet.FirstOrDefaultAsync(a =&gt; a.Email == email, ct);
///     }
/// }
/// </code>
/// </example>
[System.AttributeUsage(System.AttributeTargets.Interface, Inherited = false, AllowMultiple = false)]
public sealed class GenerateRepositoryAttribute : System.Attribute
{
    /// <summary>
    /// Optional custom class name for the generated repository.
    /// If not specified, the generator removes the 'I' prefix and adds 'Generated' suffix.
    /// </summary>
    public string? ClassName { get; set; }

    /// <summary>
    /// Whether to generate the repository as internal instead of public.
    /// </summary>
    public bool IsInternal { get; set; }
}
";
}
