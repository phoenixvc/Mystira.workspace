name: "Infrastructure: Deploy"

# Infrastructure Deployment: Flexible deployment to dev/staging/prod environments
# Steps: Validate prerequisites, bootstrap infrastructure, Terraform apply, build images, deploy K8s
# Supports: Selective component deployment, skip validation, manual triggers
# Triggers: Pushes to main (auto-deploy dev) or manual workflow_dispatch

on:
  push:
    branches: [main]
    paths:
      - "infra/terraform/**"
      - "infra/kubernetes/**"
      - ".github/workflows/infra-deploy.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      components:
        description: "Components to deploy"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - terraform-only
          - kubernetes-only
          - chain
          - publisher
      skip_validation:
        description: "Skip pre-deployment validation"
        required: false
        default: false
        type: boolean

concurrency:
  group: infra-deploy-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

env:
  TF_VERSION: "1.5.0"
  ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}
  AZURE_RESOURCE_GROUP: mys-${{ github.event.inputs.environment || 'dev' }}-core-rg-san
  AKS_CLUSTER_NAME: mys-${{ github.event.inputs.environment || 'dev' }}-core-aks-san
  ACR_NAME: myssharedacr
  DNS_ZONE: mystira.app
  DNS_ZONE_RG: mys-shared-terraform-rg-san
  TERRAFORM_RG: mys-shared-terraform-rg-san
  TERRAFORM_STORAGE: myssharedtfstatesan

jobs:
  # ============================================
  # Pre-deployment Validation
  # ============================================
  validate:
    name: Validate Prerequisites
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_validation != 'true' }}
    outputs:
      backend-exists: ${{ steps.check-backend.outputs.exists }}
      acr-exists: ${{ steps.check-acr.outputs.exists }}
      dns-zone-exists: ${{ steps.check-dns.outputs.exists }}
      aks-exists: ${{ steps.check-aks.outputs.exists }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Check Terraform Backend
        id: check-backend
        run: |
          if az storage account show --name ${{ env.TERRAFORM_STORAGE }} --resource-group ${{ env.TERRAFORM_RG }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Terraform backend storage exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::warning::Terraform backend storage does not exist - will be created"
          fi

      - name: Check Container Registry
        id: check-acr
        run: |
          if az acr show --name ${{ env.ACR_NAME }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Container Registry exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::warning::Container Registry does not exist - will be created"
          fi

      - name: Check DNS Zone
        id: check-dns
        run: |
          if az network dns zone show --name ${{ env.DNS_ZONE }} --resource-group ${{ env.DNS_ZONE_RG }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::DNS Zone exists in ${{ env.DNS_ZONE_RG }}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::warning::DNS Zone does not exist - will be created"
          fi

      - name: Check AKS Cluster
        id: check-aks
        run: |
          if az aks show --name ${{ env.AKS_CLUSTER_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster does not exist - Kubernetes deployment will be skipped"
          fi

      - name: Validation Summary
        run: |
          echo "## Pre-deployment Validation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Backend | ${{ steps.check-backend.outputs.exists == 'true' && 'âœ… Exists' || 'âš ï¸ Will Create' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Container Registry | ${{ steps.check-acr.outputs.exists == 'true' && 'âœ… Exists' || 'âš ï¸ Will Create' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| DNS Zone | ${{ steps.check-dns.outputs.exists == 'true' && 'âœ… Exists' || 'âš ï¸ Will Create' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Cluster | ${{ steps.check-aks.outputs.exists == 'true' && 'âœ… Exists' || 'â­ï¸ Not Found (K8s deploy skipped)' }} |" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # IMPORTANT: Terraform Backend Storage Permissions
  # ============================================
  # The service principal needs "Storage Blob Data Contributor" role on the
  # Terraform state storage account to access the backend (uses use_azuread_auth = true).
  #
  # This MUST be granted manually ONCE during initial setup because:
  # - The service principal only has Contributor role (creates/manages resources)
  # - Granting role assignments requires Owner or User Access Administrator role
  # - The SP cannot grant permissions to itself
  #
  # Run this from PowerShell (NOT Git Bash on Windows):
  #   az role assignment create \
  #     --assignee "4a4f8652-7323-4804-849a-9ea0b3640472" \
  #     --role "Storage Blob Data Contributor" \
  #     --scope "/subscriptions/22f9eb18-6553-4b7d-9451-47d0195085fe/resourceGroups/mys-shared-terraform-rg-san/providers/Microsoft.Storage/storageAccounts/myssharedtfstatesan"
  #
  # See infra/azure-setup.md for detailed instructions.
  # ============================================
  # Bootstrap Infrastructure Prerequisites
  # ============================================
  bootstrap:
    name: Bootstrap Infrastructure
    runs-on: ubuntu-latest
    needs: [validate]
    # Only run if validation passed/skipped AND at least one prerequisite is missing
    if: >-
      (needs.validate.result == 'success' || needs.validate.result == 'skipped') &&
      (needs.validate.outputs.backend-exists != 'true' ||
       needs.validate.outputs.acr-exists != 'true' ||
       needs.validate.outputs.dns-zone-exists != 'true')
    steps:
      - uses: actions/checkout@v6

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Create Terraform Resource Group
        if: needs.validate.outputs.backend-exists != 'true'
        run: |
          az group create \
            --name ${{ env.TERRAFORM_RG }} \
            --location southafricanorth \
            --output none
          echo "::notice::Created Terraform resource group"

      - name: Create Terraform Backend Storage
        if: needs.validate.outputs.backend-exists != 'true'
        run: |
          az storage account create \
            --name ${{ env.TERRAFORM_STORAGE }} \
            --resource-group ${{ env.TERRAFORM_RG }} \
            --location southafricanorth \
            --sku Standard_LRS \
            --kind StorageV2 \
            --output none

          STORAGE_KEY=$(az storage account keys list \
            --resource-group ${{ env.TERRAFORM_RG }} \
            --account-name ${{ env.TERRAFORM_STORAGE }} \
            --query "[0].value" -o tsv)

          az storage container create \
            --name tfstate \
            --account-name ${{ env.TERRAFORM_STORAGE }} \
            --account-key "$STORAGE_KEY" \
            --output none

          # Grant service principal access to storage account
          # Required for Terraform backend with use_azuread_auth = true
          echo "Getting service principal details..."
          SP_OBJECT_ID=$(az ad sp list --show-mine --query "[0].id" -o tsv)
          if [ -z "$SP_OBJECT_ID" ]; then
            # Fallback: Get from credentials JSON
            SP_OBJECT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientId')
            echo "Using client ID from credentials: $SP_OBJECT_ID"
          else
            echo "Using service principal object ID: $SP_OBJECT_ID"
          fi

          STORAGE_ID=$(az storage account show \
            --resource-group ${{ env.TERRAFORM_RG }} \
            --name ${{ env.TERRAFORM_STORAGE }} \
            --query id -o tsv)

          echo "Granting Storage Blob Data Contributor role..."
          az role assignment create \
            --assignee "$SP_OBJECT_ID" \
            --role "Storage Blob Data Contributor" \
            --scope "$STORAGE_ID" \
            --output none || echo "Role assignment may already exist"

          # Wait for role assignment to propagate
          echo "Waiting 10 seconds for role assignment to propagate..."
          sleep 10

          echo "::notice::Created Terraform backend storage"

      - name: Create Container Registry
        if: needs.validate.outputs.acr-exists != 'true'
        run: |
          az acr create \
            --name ${{ env.ACR_NAME }} \
            --resource-group ${{ env.TERRAFORM_RG }} \
            --location southafricanorth \
            --sku Basic \
            --admin-enabled true \
            --output none
          echo "::notice::Created Container Registry"

      - name: Create DNS Zone
        if: needs.validate.outputs.dns-zone-exists != 'true'
        run: |
          az network dns zone create \
            --name ${{ env.DNS_ZONE }} \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --output none

          echo "::warning::DNS Zone created. Update your domain registrar nameservers!"
          echo "## DNS Nameservers" >> $GITHUB_STEP_SUMMARY
          echo "Update your domain registrar with these nameservers:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          az network dns zone show --name ${{ env.DNS_ZONE }} --resource-group ${{ env.DNS_ZONE_RG }} --query nameServers -o tsv >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Grant Storage Account Permissions
        run: |
          # Always grant service principal access to storage account
          # Use the SAME service principal that Terraform will use (from secrets)
          echo "Granting storage access to service principal..."

          # Extract client ID from the credentials that Terraform uses
          SP_CLIENT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientId')
          echo "Service Principal Client ID: ${SP_CLIENT_ID:0:8}..."

          # CRITICAL: Get the Object ID from the Client ID
          # Role assignments need the Object ID, not the Client ID
          echo "Looking up service principal object ID..."
          SP_OBJECT_ID=$(az ad sp show --id "$SP_CLIENT_ID" --query id -o tsv)

          if [ -z "$SP_OBJECT_ID" ]; then
            echo "::error::Could not find service principal object ID for client ID $SP_CLIENT_ID"
            exit 1
          fi

          echo "Service Principal Object ID: ${SP_OBJECT_ID:0:8}..."

          STORAGE_ID=$(az storage account show \
            --resource-group ${{ env.TERRAFORM_RG }} \
            --name ${{ env.TERRAFORM_STORAGE }} \
            --query id -o tsv)
          echo "Storage Account: $STORAGE_ID"

          # Grant multiple roles to ensure all permissions
          echo "Granting storage permissions (this may take a moment)..."

          # Role 1: Storage Blob Data Contributor (for blob access)
          echo "Attempting to grant Storage Blob Data Contributor..."
          if az role assignment create \
            --assignee-object-id "$SP_OBJECT_ID" \
            --assignee-principal-type ServicePrincipal \
            --role "Storage Blob Data Contributor" \
            --scope "$STORAGE_ID"; then
            echo "âœ“ Granted Storage Blob Data Contributor"
          else
            echo "âš  Failed to grant Storage Blob Data Contributor (may already exist)"
          fi

          # Role 2: Storage Account Contributor (for account-level operations)
          echo "Attempting to grant Storage Account Contributor..."
          if az role assignment create \
            --assignee-object-id "$SP_OBJECT_ID" \
            --assignee-principal-type ServicePrincipal \
            --role "Storage Account Contributor" \
            --scope "$STORAGE_ID"; then
            echo "âœ“ Granted Storage Account Contributor"
          else
            echo "âš  Failed to grant Storage Account Contributor (may already exist)"
          fi

          # Role 3: Reader and Data Access (sometimes needed)
          echo "Attempting to grant Reader and Data Access..."
          if az role assignment create \
            --assignee-object-id "$SP_OBJECT_ID" \
            --assignee-principal-type ServicePrincipal \
            --role "Reader and Data Access" \
            --scope "$STORAGE_ID"; then
            echo "âœ“ Granted Reader and Data Access"
          else
            echo "âš  Failed to grant Reader and Data Access (may already exist)"
          fi

          echo "âœ“ Storage roles configured"

          # Verify permissions were granted
          echo ""
          echo "Verifying role assignments..."
          az role assignment list \
            --assignee "$SP_OBJECT_ID" \
            --scope "$STORAGE_ID" \
            --query "[].{Role:roleDefinitionName, Scope:scope}" \
            --output table

          echo ""
          echo "Role assignment count:"
          ROLE_COUNT=$(az role assignment list \
            --assignee "$SP_OBJECT_ID" \
            --scope "$STORAGE_ID" \
            --query "length(@)" -o tsv)
          echo "  Found $ROLE_COUNT role assignment(s) for this service principal on the storage account"

          if [ "$ROLE_COUNT" -eq "0" ]; then
            echo "::error::No role assignments found! Permission grant may have failed."
            exit 1
          fi

          # Wait for Azure AD propagation (increased wait time)
          echo ""
          echo "Waiting 30 seconds for Azure AD to propagate permissions..."
          sleep 30

          echo "::notice::Storage permissions configured and verified"

  # ============================================
  # Terraform Plan
  # ============================================
  plan-terraform:
    name: Plan Terraform
    runs-on: ubuntu-latest
    needs: [validate, bootstrap]
    if: |
      always() &&
      (needs.validate.result == 'success' || needs.validate.result == 'skipped') &&
      (needs.bootstrap.result == 'success' || needs.bootstrap.result == 'skipped') &&
      (github.event.inputs.components == 'all' || github.event.inputs.components == 'terraform-only' || github.event.inputs.components == '')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      has-changes: ${{ steps.plan.outputs.changes }}
      aks-exists: ${{ steps.check-aks-plan.outputs.exists }}
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Set Azure credentials for Terraform
        run: |
          ARM_CLIENT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientId')
          ARM_CLIENT_SECRET=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          ARM_SUBSCRIPTION_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
          ARM_TENANT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          echo "::add-mask::$ARM_CLIENT_SECRET"
          {
            echo "ARM_CLIENT_ID=$ARM_CLIENT_ID"
            echo "ARM_CLIENT_SECRET=$ARM_CLIENT_SECRET"
            echo "ARM_SUBSCRIPTION_ID=$ARM_SUBSCRIPTION_ID"
            echo "ARM_TENANT_ID=$ARM_TENANT_ID"
            echo "ARM_USE_CLI=false"
          } >> "$GITHUB_ENV"

      - name: Terraform Init
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          terraform init

      - name: Import Existing Resources
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}

          # Get subscription ID from Azure CLI
          SUBSCRIPTION_ID=$(az account show --query id -o tsv)

          # Check if resource group exists in Azure but not in state
          if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "Resource group exists in Azure, checking if in state..."
            if ! terraform state list 2>/dev/null | grep -q "azurerm_resource_group.main"; then
              echo "Resource group not in state, importing..."
              terraform import azurerm_resource_group.main "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}"
              echo "::notice::Imported existing resource group into Terraform state"
            else
              echo "Resource group already in state"
            fi
          else
            echo "Resource group does not exist in Azure - will be created"
          fi

          # All environments use South Africa North (san)
          REGION_CODE="san"
          VNET_NAME="mys-${{ env.ENVIRONMENT }}-core-vnet-${REGION_CODE}"

          # Check if VNet exists in Azure but not in state
          if az network vnet show --name "${VNET_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "VNet exists in Azure, checking if in state..."
            if ! terraform state list 2>/dev/null | grep -q "azurerm_virtual_network.main"; then
              echo "VNet not in state, importing..."
              terraform import azurerm_virtual_network.main "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}/providers/Microsoft.Network/virtualNetworks/${VNET_NAME}"
              echo "::notice::Imported existing VNet into Terraform state"
            else
              echo "VNet already in state"
            fi
          fi

          # Check if ACR exists in Azure but not in state (ACR is shared across environments)
          if az acr show --name ${{ env.ACR_NAME }} &> /dev/null; then
            echo "ACR exists in Azure, checking if in state..."
            if ! terraform state list 2>/dev/null | grep -q "azurerm_container_registry.shared"; then
              # Get the resource group where ACR actually exists
              ACR_RG=$(az acr show --name ${{ env.ACR_NAME }} --query resourceGroup -o tsv)
              echo "ACR not in state, importing from resource group ${ACR_RG}..."
              terraform import azurerm_container_registry.shared "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${ACR_RG}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}"
              echo "::notice::Imported existing ACR into Terraform state"
            else
              echo "ACR already in state"
            fi
          fi

      - name: Terraform Refresh (sync state with Azure)
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          terraform refresh || true
          # Remove AKS from state if it exists but not in Azure - forces recreation
          if ! az aks show --name ${{ env.AKS_CLUSTER_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "AKS not found in Azure, checking if in state..."
            if terraform state list 2>/dev/null | grep -q "azurerm_kubernetes_cluster.main"; then
              echo "Removing stale AKS from state..."
              terraform state rm azurerm_kubernetes_cluster.main
            else
              echo "AKS not in state either - will be created fresh"
            fi
          fi

      - name: Terraform Plan
        id: plan
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          set +e
          terraform plan -out=tfplan -detailed-exitcode
          PLAN_EXIT=$?
          echo "Terraform plan exit code: $PLAN_EXIT"
          if [ $PLAN_EXIT -eq 1 ]; then
            echo "Terraform plan failed"
            exit 1
          elif [ $PLAN_EXIT -eq 2 ]; then
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "Changes detected - will apply"
          else
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "No changes needed"
          fi

      - name: Upload Plan
        if: steps.plan.outputs.changes == 'true'
        uses: actions/upload-artifact@v6
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: infra/terraform/environments/${{ env.ENVIRONMENT }}/tfplan
          retention-days: 5

      - name: Check AKS Cluster (for downstream jobs)
        id: check-aks-plan
        run: |
          if az aks show --name ${{ env.AKS_CLUSTER_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster does not exist"
          fi

      - name: Plan Summary
        run: |
          echo "## Terraform Plan - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.plan.outputs.changes }}" == "true" ]; then
            echo "ðŸ“ Changes detected - will apply" >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… No changes needed" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "AKS Cluster: ${{ steps.check-aks-plan.outputs.exists == 'true' && 'âœ… Exists' || 'âŒ Not Found' }}" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Terraform Apply
  # ============================================
  apply-terraform:
    name: Apply Terraform
    runs-on: ubuntu-latest
    needs: [plan-terraform]
    if: always() && needs.plan-terraform.result == 'success'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      aks-exists: ${{ steps.check-aks-post-apply.outputs.exists }}
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Set Azure credentials for Terraform
        run: |
          ARM_CLIENT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientId')
          ARM_CLIENT_SECRET=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          ARM_SUBSCRIPTION_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
          ARM_TENANT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          echo "::add-mask::$ARM_CLIENT_SECRET"
          {
            echo "ARM_CLIENT_ID=$ARM_CLIENT_ID"
            echo "ARM_CLIENT_SECRET=$ARM_CLIENT_SECRET"
            echo "ARM_SUBSCRIPTION_ID=$ARM_SUBSCRIPTION_ID"
            echo "ARM_TENANT_ID=$ARM_TENANT_ID"
            echo "ARM_USE_CLI=false"
          } >> "$GITHUB_ENV"

      - name: Download Plan
        uses: actions/download-artifact@v7
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: infra/terraform/environments/${{ env.ENVIRONMENT }}

      - name: Terraform Init
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          terraform init

      - name: Terraform Apply
        id: apply
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          terraform apply -auto-approve

      - name: Check AKS Cluster After Apply
        id: check-aks-post-apply
        run: |
          if az aks show --name ${{ env.AKS_CLUSTER_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster exists after Terraform apply"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster not found after Terraform apply"
          fi

      - name: Apply Summary
        run: |
          echo "## Terraform Apply - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Infrastructure applied successfully" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Configure DNS Records (AKS-based)
  # ============================================
  configure-dns:
    name: Configure DNS
    runs-on: ubuntu-latest
    needs: [deploy-kubernetes]
    if: |
      always() &&
      needs.deploy-kubernetes.result == 'success' &&
      needs.deploy-kubernetes.outputs.ingress-ip != ''
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Configure DNS A Records
        run: |
          INGRESS_IP="${{ needs.deploy-kubernetes.outputs.ingress-ip }}"
          ENV_PREFIX="${{ env.ENVIRONMENT }}"
          if [ "$ENV_PREFIX" == "prod" ]; then
            ENV_PREFIX=""
          else
            ENV_PREFIX="${ENV_PREFIX}."
          fi

          echo "Configuring DNS records to point to $INGRESS_IP"

          # Configure Publisher DNS
          az network dns record-set a add-record \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --zone-name ${{ env.DNS_ZONE }} \
            --record-set-name "${ENV_PREFIX}publisher" \
            --ipv4-address "$INGRESS_IP" \
            --if-none-match || true

          # Configure Chain DNS
          az network dns record-set a add-record \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --zone-name ${{ env.DNS_ZONE }} \
            --record-set-name "${ENV_PREFIX}chain" \
            --ipv4-address "$INGRESS_IP" \
            --if-none-match || true

          # Configure API DNS
          az network dns record-set a add-record \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --zone-name ${{ env.DNS_ZONE }} \
            --record-set-name "${ENV_PREFIX}api" \
            --ipv4-address "$INGRESS_IP" \
            --if-none-match || true

          # Configure Story Generator DNS
          az network dns record-set a add-record \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --zone-name ${{ env.DNS_ZONE }} \
            --record-set-name "${ENV_PREFIX}story-generator" \
            --ipv4-address "$INGRESS_IP" \
            --if-none-match || true

          echo "::notice::DNS records configured for ${{ env.ENVIRONMENT }} pointing to $INGRESS_IP"

      - name: Check DNS Nameserver Configuration
        run: |
          echo "## DNS Nameserver Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get Azure DNS nameservers for our zone
          AZURE_NS=$(az network dns zone show --name ${{ env.DNS_ZONE }} --resource-group ${{ env.DNS_ZONE_RG }} --query "nameServers[0]" -o tsv | sed 's/\.$//')

          # Check if domain is using Azure DNS
          ACTUAL_NS=$(dig +short NS ${{ env.DNS_ZONE }} | head -1 | sed 's/\.$//')

          if echo "$ACTUAL_NS" | grep -q "azure-dns"; then
            echo "âœ… Domain is using Azure DNS nameservers" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ **Domain is NOT using Azure DNS!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The A records were created in Azure DNS, but your domain is using:" >> $GITHUB_STEP_SUMMARY
            echo "\`$ACTUAL_NS\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**To fix this, either:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Update your domain registrar's nameservers to Azure DNS:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            az network dns zone show --name ${{ env.DNS_ZONE }} --resource-group ${{ env.DNS_ZONE_RG }} --query nameServers -o tsv >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "2. Or create A records in your current DNS provider pointing to: **${{ needs.deploy-kubernetes.outputs.ingress-ip }}**" >> $GITHUB_STEP_SUMMARY
            echo "::warning::Domain ${{ env.DNS_ZONE }} is not using Azure DNS nameservers. DNS records may not resolve."
          fi

      - name: DNS Summary
        run: |
          INGRESS_IP="${{ needs.deploy-kubernetes.outputs.ingress-ip }}"
          echo "## DNS Configuration - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Load Balancer IP: $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.ENVIRONMENT }}" == "prod" ]; then
            echo "| Publisher | https://publisher.mystira.app |" >> $GITHUB_STEP_SUMMARY
            echo "| Chain | https://chain.mystira.app |" >> $GITHUB_STEP_SUMMARY
            echo "| API | https://api.mystira.app |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Publisher | https://${{ env.ENVIRONMENT }}.publisher.mystira.app |" >> $GITHUB_STEP_SUMMARY
            echo "| Chain | https://${{ env.ENVIRONMENT }}.chain.mystira.app |" >> $GITHUB_STEP_SUMMARY
            echo "| API | https://${{ env.ENVIRONMENT }}.api.mystira.app |" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================
  # Build and Push Docker Images
  # ============================================
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [apply-terraform]
    if: |
      always() &&
      (needs.apply-terraform.result == 'success' || needs.apply-terraform.result == 'skipped') &&
      (github.event.inputs.components == 'all' || github.event.inputs.components == '')
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
          token: ${{ secrets.GH_PAT }}
          persist-credentials: true

      - name: Verify submodules
        run: |
          echo "Checking submodule status..."
          git submodule status
          echo ""
          echo "Packages directory contents:"
          ls -la packages/
          echo ""
          echo "Chain package contents:"
          ls -la packages/chain/ || echo "Chain directory empty or missing"
          echo ""
          echo "Publisher package contents:"
          ls -la packages/publisher/ || echo "Publisher directory empty or missing"
          echo ""
          # Fail if submodules are empty (chain is Python, publisher is Node.js)
          if [ ! -f "packages/chain/server.py" ]; then
            echo "::error::packages/chain/server.py not found - submodule checkout failed"
            echo "Make sure GH_PAT has access to https://github.com/phoenixvc/Mystira.Chain"
            exit 1
          fi
          if [ ! -f "packages/publisher/package.json" ]; then
            echo "::error::packages/publisher/package.json not found - submodule checkout failed"
            echo "Make sure GH_PAT has access to https://github.com/phoenixvc/Mystira.Publisher"
            exit 1
          fi
          echo "âœ… Submodules verified successfully"

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and Push Publisher
        run: |
          docker build \
            -t ${{ env.ACR_NAME }}.azurecr.io/publisher:${{ env.ENVIRONMENT }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/publisher:${{ github.sha }} \
            -f infra/docker/publisher/Dockerfile \
            .
          docker push ${{ env.ACR_NAME }}.azurecr.io/publisher:${{ env.ENVIRONMENT }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/publisher:${{ github.sha }}

      - name: Build and Push Chain
        run: |
          docker build \
            -t ${{ env.ACR_NAME }}.azurecr.io/chain:${{ env.ENVIRONMENT }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/chain:${{ github.sha }} \
            -f infra/docker/chain/Dockerfile \
            .
          docker push ${{ env.ACR_NAME }}.azurecr.io/chain:${{ env.ENVIRONMENT }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/chain:${{ github.sha }}

      - name: Image Summary
        run: |
          echo "## Docker Images Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Image | Tags |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| publisher | ${{ env.ENVIRONMENT }}, ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| chain | ${{ env.ENVIRONMENT }}, ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Deploy to Kubernetes
  # ============================================
  deploy-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [apply-terraform, build-images]
    if: |
      always() &&
      (needs.apply-terraform.outputs.aks-exists == 'true') &&
      (needs.apply-terraform.result == 'success' || needs.apply-terraform.result == 'skipped') &&
      (needs.build-images.result == 'success' || needs.build-images.result == 'skipped') &&
      (github.event.inputs.components == 'all' ||
       github.event.inputs.components == 'kubernetes-only' ||
       github.event.inputs.components == 'chain' ||
       github.event.inputs.components == 'publisher' ||
       github.event.inputs.components == '')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      ingress-ip: ${{ steps.get-ingress-ip.outputs.ip }}
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Create namespace
        run: |
          kubectl create namespace mys-${{ env.ENVIRONMENT }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Enable ACR Admin
        run: |
          az acr update --name ${{ env.ACR_NAME }} --admin-enabled true --output none

      - name: Create ACR Pull Secret
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          kubectl create secret docker-registry acr-secret \
            --namespace mys-${{ env.ENVIRONMENT }} \
            --docker-server=${{ env.ACR_NAME }}.azurecr.io \
            --docker-username=$ACR_USERNAME \
            --docker-password=$ACR_PASSWORD \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy NGINX Ingress Controller
        id: get-ingress-ip
        run: |
          # Deploy NGINX Ingress Controller
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml

          # Wait for ingress controller to be ready
          echo "Waiting for NGINX Ingress Controller..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=300s || true

          # Wait for LoadBalancer IP
          echo "Waiting for LoadBalancer IP..."
          INGRESS_IP=""
          for i in {1..30}; do
            INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            if [ -n "$INGRESS_IP" ]; then
              echo "Ingress Controller IP: $INGRESS_IP"
              break
            fi
            echo "Waiting for LoadBalancer IP... ($i/30)"
            sleep 10
          done
          echo "ip=$INGRESS_IP" >> $GITHUB_OUTPUT

      - name: Deploy cert-manager
        run: |
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml || true
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s || true

      - name: Clear old TLS certificates
        run: |
          # Delete old certificate secrets so cert-manager issues fresh ones
          echo "Clearing old TLS certificates..."
          kubectl delete secret mystira-publisher-tls -n mys-${{ env.ENVIRONMENT }} --ignore-not-found
          kubectl delete secret mystira-publisher-tls-dev -n mys-${{ env.ENVIRONMENT }} --ignore-not-found
          kubectl delete secret mystira-chain-tls -n mys-${{ env.ENVIRONMENT }} --ignore-not-found
          kubectl delete secret mystira-chain-tls-dev -n mys-${{ env.ENVIRONMENT }} --ignore-not-found
          # Also delete any certificate resources so they get recreated
          kubectl delete certificate --all -n mys-${{ env.ENVIRONMENT }} --ignore-not-found || true
          echo "Old certificates cleared"

      - name: Deploy Applications
        run: |
          kubectl apply -k infra/kubernetes/overlays/${{ env.ENVIRONMENT }}

      - name: Wait for Deployments
        run: |
          echo "Waiting for deployments to be ready..."
          kubectl rollout status deployment/mys-publisher -n mys-${{ env.ENVIRONMENT }} --timeout=300s || true
          kubectl rollout status statefulset/mys-chain -n mys-${{ env.ENVIRONMENT }} --timeout=600s || true

      - name: Deployment Summary
        run: |
          echo "## Kubernetes Deployment - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pods" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n mys-${{ env.ENVIRONMENT }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Services" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get svc -n mys-${{ env.ENVIRONMENT }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Ingress" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get ingress -n mys-${{ env.ENVIRONMENT }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Final Summary
  # ============================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [validate, bootstrap, plan-terraform, apply-terraform, build-images, configure-dns, deploy-kubernetes]
    if: always()
    steps:
      - name: Final Summary
        run: |
          echo "# Deployment Summary - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Validation | ${{ needs.validate.result == 'success' && 'âœ…' || needs.validate.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Bootstrap | ${{ needs.bootstrap.result == 'success' && 'âœ…' || needs.bootstrap.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Plan | ${{ needs.plan-terraform.result == 'success' && 'âœ…' || needs.plan-terraform.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Apply | ${{ needs.apply-terraform.result == 'success' && 'âœ…' || needs.apply-terraform.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| DNS Config | ${{ needs.configure-dns.result == 'success' && 'âœ…' || needs.configure-dns.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Images | ${{ needs.build-images.result == 'success' && 'âœ…' || needs.build-images.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy K8s | ${{ needs.deploy-kubernetes.result == 'success' && 'âœ…' || needs.deploy-kubernetes.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Environment URLs" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.ENVIRONMENT }}" == "prod" ]; then
            echo "- Publisher: https://publisher.mystira.app" >> $GITHUB_STEP_SUMMARY
            echo "- Chain: https://chain.mystira.app" >> $GITHUB_STEP_SUMMARY
            echo "- API: https://api.mystira.app" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Publisher: https://${{ env.ENVIRONMENT }}.publisher.mystira.app" >> $GITHUB_STEP_SUMMARY
            echo "- Chain: https://${{ env.ENVIRONMENT }}.chain.mystira.app" >> $GITHUB_STEP_SUMMARY
            echo "- API: https://${{ env.ENVIRONMENT }}.api.mystira.app" >> $GITHUB_STEP_SUMMARY
          fi
