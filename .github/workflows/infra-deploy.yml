name: "Infrastructure: Deploy"

# Infrastructure Deployment: Flexible deployment to dev/staging/prod environments
# Steps: Validate prerequisites, bootstrap infrastructure, Terraform apply, build images, deploy K8s
# Supports: Selective component deployment, skip validation, manual triggers
# Triggers: Pushes to main (auto-deploy dev) or manual workflow_dispatch

on:
  push:
    branches: [main]
    paths:
      - "infra/terraform/**"
      - "infra/kubernetes/**"
      - ".github/workflows/infra-deploy.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      components:
        description: "Components to deploy"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - terraform-only
          - kubernetes-only
          - chain
          - publisher
      skip_validation:
        description: "Skip pre-deployment validation"
        required: false
        default: false
        type: boolean

concurrency:
  group: infra-deploy-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

env:
  TF_VERSION: "1.5.0"
  ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}
  AZURE_RESOURCE_GROUP: mys-${{ github.event.inputs.environment || 'dev' }}-core-rg-san
  AKS_CLUSTER_NAME: mys-${{ github.event.inputs.environment || 'dev' }}-core-aks-san
  ACR_NAME: myssharedacr
  DNS_ZONE: mystira.app
  DNS_ZONE_RG: mys-shared-terraform-rg-san
  TERRAFORM_RG: mys-shared-terraform-rg-san
  TERRAFORM_STORAGE: myssharedtfstatesan

jobs:
  # ============================================
  # Pre-deployment Validation
  # ============================================
  validate:
    name: Validate Prerequisites
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_validation != 'true' }}
    outputs:
      backend-exists: ${{ steps.check-backend.outputs.exists }}
      acr-exists: ${{ steps.check-acr.outputs.exists }}
      dns-zone-exists: ${{ steps.check-dns.outputs.exists }}
      aks-exists: ${{ steps.check-aks.outputs.exists }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Check Terraform Backend
        id: check-backend
        run: |
          if az storage account show --name ${{ env.TERRAFORM_STORAGE }} --resource-group ${{ env.TERRAFORM_RG }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Terraform backend storage exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::warning::Terraform backend storage does not exist - will be created"
          fi

      - name: Check Container Registry
        id: check-acr
        run: |
          if az acr show --name ${{ env.ACR_NAME }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Container Registry exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::warning::Container Registry does not exist - will be created"
          fi

      - name: Check DNS Zone
        id: check-dns
        run: |
          if az network dns zone show --name ${{ env.DNS_ZONE }} --resource-group ${{ env.DNS_ZONE_RG }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::DNS Zone exists in ${{ env.DNS_ZONE_RG }}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::warning::DNS Zone does not exist - will be created"
          fi

      - name: Check AKS Cluster
        id: check-aks
        run: |
          if az aks show --name ${{ env.AKS_CLUSTER_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster does not exist - Kubernetes deployment will be skipped"
          fi

      - name: Check Service Principal Permissions
        id: check-permissions
        run: |
          echo "Checking service principal permissions..."
          PERMISSION_ISSUES=""

          # Get service principal info
          SP_CLIENT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientId')
          SP_OBJECT_ID=$(az ad sp show --id "$SP_CLIENT_ID" --query id -o tsv 2>/dev/null || echo "")
          SUBSCRIPTION_ID=$(az account show --query id -o tsv)

          if [ -z "$SP_OBJECT_ID" ]; then
            echo "::error::Could not retrieve service principal object ID"
            echo "sp-valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "Service Principal Object ID: $SP_OBJECT_ID"

          # Check 1: Azure AD App Registration permissions
          echo "Checking Azure AD permissions..."
          # Try to list apps to verify we have some Graph API access
          if ! az ad app list --filter "displayName eq 'permission-test-$(date +%s)'" --query "[].id" -o tsv &>/dev/null; then
            PERMISSION_ISSUES="${PERMISSION_ISSUES}\n- Missing Azure AD permissions (Application.ReadWrite.All or Application Administrator role)"
            echo "has-ad-permissions=false" >> $GITHUB_OUTPUT
          else
            echo "has-ad-permissions=true" >> $GITHUB_OUTPUT
            echo "::notice::Azure AD permissions OK"
          fi

          # Check 2: Role assignment permissions (User Access Administrator)
          echo "Checking role assignment permissions..."
          # Check if SP has User Access Administrator or Owner at subscription level
          HAS_UAA=$(az role assignment list \
            --assignee "$SP_OBJECT_ID" \
            --scope "/subscriptions/${SUBSCRIPTION_ID}" \
            --query "[?roleDefinitionName=='User Access Administrator' || roleDefinitionName=='Owner'].roleDefinitionName" \
            -o tsv 2>/dev/null | head -1)

          if [ -z "$HAS_UAA" ]; then
            # Check at resource group level
            HAS_UAA=$(az role assignment list \
              --assignee "$SP_OBJECT_ID" \
              --scope "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}" \
              --query "[?roleDefinitionName=='User Access Administrator' || roleDefinitionName=='Owner'].roleDefinitionName" \
              -o tsv 2>/dev/null | head -1)
          fi

          if [ -z "$HAS_UAA" ]; then
            PERMISSION_ISSUES="${PERMISSION_ISSUES}\n- Missing User Access Administrator role (cannot create role assignments)"
            echo "has-rbac-permissions=false" >> $GITHUB_OUTPUT
          else
            echo "has-rbac-permissions=true" >> $GITHUB_OUTPUT
            echo "::notice::Role assignment permissions OK ($HAS_UAA)"
          fi

          # Check 3: Front Door WAF policy conflicts
          echo "Checking for WAF policy conflicts..."
          if az afd profile show --profile-name "mystira-${{ env.ENVIRONMENT }}-fd" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            EXISTING_POLICIES=$(az afd security-policy list \
              --profile-name "mystira-${{ env.ENVIRONMENT }}-fd" \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --query "[].name" -o tsv 2>/dev/null || echo "")

            if [ -n "$EXISTING_POLICIES" ]; then
              echo "::warning::Existing WAF security policies found: $EXISTING_POLICIES"
              echo "waf-policies=$EXISTING_POLICIES" >> $GITHUB_OUTPUT
            fi
          fi
          echo "has-waf-conflict=false" >> $GITHUB_OUTPUT

          # Summary
          if [ -n "$PERMISSION_ISSUES" ]; then
            echo "::warning::Permission issues detected:$PERMISSION_ISSUES"
            echo "## âš ï¸ Permission Issues Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following permissions are missing from the service principal:" >> $GITHUB_STEP_SUMMARY
            echo -e "$PERMISSION_ISSUES" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### How to Fix" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Azure AD Permissions:**" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo "# Option 1: Add API permission (requires admin consent)" >> $GITHUB_STEP_SUMMARY
            echo "az ad app permission add --id $SP_CLIENT_ID --api 00000003-0000-0000-c000-000000000000 --api-permissions 1bfefb4e-e0b5-418b-a88f-73c46d2cc8e9=Role" >> $GITHUB_STEP_SUMMARY
            echo "az ad app permission admin-consent --id $SP_CLIENT_ID" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Option 2: Assign Application Administrator role" >> $GITHUB_STEP_SUMMARY
            echo "az rest --method POST --url 'https://graph.microsoft.com/v1.0/directoryRoles/roleTemplateId=9b895d92-2cd3-44c7-9d02-a6ac2d5ea5c3/members/\$ref' --body '{\"@odata.id\":\"https://graph.microsoft.com/v1.0/directoryObjects/$SP_OBJECT_ID\"}'" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Role Assignment Permissions:**" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo "az role assignment create \\" >> $GITHUB_STEP_SUMMARY
            echo "  --assignee $SP_OBJECT_ID \\" >> $GITHUB_STEP_SUMMARY
            echo "  --role 'User Access Administrator' \\" >> $GITHUB_STEP_SUMMARY
            echo "  --scope /subscriptions/$SUBSCRIPTION_ID" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

          echo "sp-valid=true" >> $GITHUB_OUTPUT

      - name: Validation Summary
        run: |
          echo "## Pre-deployment Validation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Resources" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Backend | ${{ steps.check-backend.outputs.exists == 'true' && 'âœ… Exists' || 'âš ï¸ Will Create' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Container Registry | ${{ steps.check-acr.outputs.exists == 'true' && 'âœ… Exists' || 'âš ï¸ Will Create' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| DNS Zone | ${{ steps.check-dns.outputs.exists == 'true' && 'âœ… Exists' || 'âš ï¸ Will Create' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Cluster | ${{ steps.check-aks.outputs.exists == 'true' && 'âœ… Exists' || 'â­ï¸ Not Found (K8s deploy skipped)' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Service Principal Permissions" >> $GITHUB_STEP_SUMMARY
          echo "| Permission | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Azure AD (App Registration) | ${{ steps.check-permissions.outputs.has-ad-permissions == 'true' && 'âœ… OK' || 'âŒ Missing' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| RBAC (Role Assignments) | ${{ steps.check-permissions.outputs.has-rbac-permissions == 'true' && 'âœ… OK' || 'âŒ Missing' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| WAF Policy Conflicts | ${{ steps.check-permissions.outputs.waf-policies == '' && 'âœ… None' || 'âš ï¸ Check Above' }} |" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Bootstrap Infrastructure Prerequisites
  # ============================================
  bootstrap:
    name: Bootstrap Infrastructure
    runs-on: ubuntu-latest
    needs: [validate]
    # Only run if validation passed/skipped AND at least one prerequisite is missing
    if: >-
      (needs.validate.result == 'success' || needs.validate.result == 'skipped') &&
      (needs.validate.outputs.backend-exists != 'true' ||
       needs.validate.outputs.acr-exists != 'true' ||
       needs.validate.outputs.dns-zone-exists != 'true')
    steps:
      - uses: actions/checkout@v6

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Create Terraform Resource Group
        if: needs.validate.outputs.backend-exists != 'true'
        run: |
          az group create \
            --name ${{ env.TERRAFORM_RG }} \
            --location southafricanorth \
            --output none
          echo "::notice::Created Terraform resource group"

      - name: Create Terraform Backend Storage
        if: needs.validate.outputs.backend-exists != 'true'
        run: |
          az storage account create \
            --name ${{ env.TERRAFORM_STORAGE }} \
            --resource-group ${{ env.TERRAFORM_RG }} \
            --location southafricanorth \
            --sku Standard_LRS \
            --kind StorageV2 \
            --output none

          STORAGE_KEY=$(az storage account keys list \
            --resource-group ${{ env.TERRAFORM_RG }} \
            --account-name ${{ env.TERRAFORM_STORAGE }} \
            --query "[0].value" -o tsv)

          az storage container create \
            --name tfstate \
            --account-name ${{ env.TERRAFORM_STORAGE }} \
            --account-key "$STORAGE_KEY" \
            --output none

          echo "::notice::Created Terraform backend storage"

      - name: Create Container Registry
        if: needs.validate.outputs.acr-exists != 'true'
        run: |
          az acr create \
            --name ${{ env.ACR_NAME }} \
            --resource-group ${{ env.TERRAFORM_RG }} \
            --location southafricanorth \
            --sku Basic \
            --admin-enabled true \
            --output none
          echo "::notice::Created Container Registry"

      - name: Create DNS Zone
        if: needs.validate.outputs.dns-zone-exists != 'true'
        run: |
          az network dns zone create \
            --name ${{ env.DNS_ZONE }} \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --output none

          echo "::warning::DNS Zone created. Update your domain registrar nameservers!"
          echo "## DNS Nameservers" >> $GITHUB_STEP_SUMMARY
          echo "Update your domain registrar with these nameservers:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          az network dns zone show --name ${{ env.DNS_ZONE }} --resource-group ${{ env.DNS_ZONE_RG }} --query nameServers -o tsv >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Grant Storage Account Permissions
        run: |
          # Grant service principal access to Terraform state storage
          SP_CLIENT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientId')
          SP_OBJECT_ID=$(az ad sp show --id "$SP_CLIENT_ID" --query id -o tsv)
          if [ -z "$SP_OBJECT_ID" ]; then
            echo "::error::Could not find service principal object ID"
            exit 1
          fi

          STORAGE_ID=$(az storage account show \
            --resource-group ${{ env.TERRAFORM_RG }} \
            --name ${{ env.TERRAFORM_STORAGE }} \
            --query id -o tsv)

          # Grant required storage roles (idempotent - safe to run multiple times)
          echo "Configuring storage permissions..."
          for role in "Storage Blob Data Contributor" "Storage Account Contributor" "Reader and Data Access"; do
            az role assignment create \
              --assignee-object-id "$SP_OBJECT_ID" \
              --assignee-principal-type ServicePrincipal \
              --role "$role" \
              --scope "$STORAGE_ID" \
              --output none 2>/dev/null || true
          done

          # Verify at least one role was assigned
          ROLE_COUNT=$(az role assignment list \
            --assignee "$SP_OBJECT_ID" \
            --scope "$STORAGE_ID" \
            --query "length(@)" -o tsv)

          if [ "$ROLE_COUNT" -eq "0" ]; then
            echo "::error::No role assignments found!"
            exit 1
          fi

          echo "::notice::Storage permissions configured ($ROLE_COUNT roles assigned)"
          # Wait for Azure AD propagation
          sleep 15

  # ============================================
  # Terraform Plan
  # ============================================
  plan-terraform:
    name: Plan Terraform
    runs-on: ubuntu-latest
    needs: [validate, bootstrap]
    if: |
      always() &&
      (needs.validate.result == 'success' || needs.validate.result == 'skipped') &&
      (needs.bootstrap.result == 'success' || needs.bootstrap.result == 'skipped') &&
      (github.event.inputs.components == 'all' || github.event.inputs.components == 'terraform-only' || github.event.inputs.components == '')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      has-changes: ${{ steps.plan.outputs.changes }}
      aks-exists: ${{ steps.check-aks-plan.outputs.exists }}
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Set Azure credentials for Terraform
        run: |
          ARM_CLIENT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientId')
          ARM_CLIENT_SECRET=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          ARM_SUBSCRIPTION_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
          ARM_TENANT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          echo "::add-mask::$ARM_CLIENT_SECRET"
          {
            echo "ARM_CLIENT_ID=$ARM_CLIENT_ID"
            echo "ARM_CLIENT_SECRET=$ARM_CLIENT_SECRET"
            echo "ARM_SUBSCRIPTION_ID=$ARM_SUBSCRIPTION_ID"
            echo "ARM_TENANT_ID=$ARM_TENANT_ID"
            echo "ARM_USE_CLI=false"
          } >> "$GITHUB_ENV"

      - name: Terraform Init
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          terraform init -upgrade

      - name: Import Existing Resources
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}

          # Get subscription ID from Azure CLI
          SUBSCRIPTION_ID=$(az account show --query id -o tsv)

          # Check if resource group exists in Azure but not in state
          if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "Resource group exists in Azure, checking if in state..."
            if ! terraform state list 2>/dev/null | grep -q "azurerm_resource_group.main"; then
              echo "Resource group not in state, importing..."
              terraform import azurerm_resource_group.main "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}"
              echo "::notice::Imported existing resource group into Terraform state"
            else
              echo "Resource group already in state"
            fi
          else
            echo "Resource group does not exist in Azure - will be created"
          fi

          # All environments use South Africa North (san)
          REGION_CODE="san"
          VNET_NAME="mys-${{ env.ENVIRONMENT }}-core-vnet-${REGION_CODE}"

          # Check if VNet exists in Azure but not in state
          if az network vnet show --name "${VNET_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "VNet exists in Azure, checking if in state..."
            if ! terraform state list 2>/dev/null | grep -q "azurerm_virtual_network.main"; then
              echo "VNet not in state, importing..."
              terraform import azurerm_virtual_network.main "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}/providers/Microsoft.Network/virtualNetworks/${VNET_NAME}"
              echo "::notice::Imported existing VNet into Terraform state"
            else
              echo "VNet already in state"
            fi
          fi

          # Check if ACR exists in Azure but not in state (ACR is shared across environments)
          if az acr show --name ${{ env.ACR_NAME }} &> /dev/null; then
            echo "ACR exists in Azure, checking if in state..."
            if ! terraform state list 2>/dev/null | grep -q "azurerm_container_registry.shared"; then
              # Get the resource group where ACR actually exists
              ACR_RG=$(az acr show --name ${{ env.ACR_NAME }} --query resourceGroup -o tsv)
              echo "ACR not in state, importing from resource group ${ACR_RG}..."
              terraform import azurerm_container_registry.shared "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${ACR_RG}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}"
              echo "::notice::Imported existing ACR into Terraform state"
            else
              echo "ACR already in state"
            fi
          fi

          # Import admin_api module resources if they exist in Azure but not in state
          ADMIN_NSG_NAME="mys-${{ env.ENVIRONMENT }}-admin-api-nsg-${REGION_CODE}"
          ADMIN_IDENTITY_NAME="mys-${{ env.ENVIRONMENT }}-admin-api-identity-${REGION_CODE}"
          ADMIN_AI_NAME="mys-${{ env.ENVIRONMENT }}-admin-api-ai-${REGION_CODE}"

          # Admin API Network Security Group
          if az network nsg show --name "${ADMIN_NSG_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            if ! terraform state list 2>/dev/null | grep -q "module.admin_api.azurerm_network_security_group.admin_api"; then
              echo "Importing admin_api NSG..."
              terraform import 'module.admin_api.azurerm_network_security_group.admin_api' \
                "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}/providers/Microsoft.Network/networkSecurityGroups/${ADMIN_NSG_NAME}" || true
            fi
          fi

          # Admin API User Assigned Identity
          if az identity show --name "${ADMIN_IDENTITY_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            if ! terraform state list 2>/dev/null | grep -q "module.admin_api.azurerm_user_assigned_identity.admin_api"; then
              echo "Importing admin_api User Assigned Identity..."
              terraform import 'module.admin_api.azurerm_user_assigned_identity.admin_api' \
                "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/${ADMIN_IDENTITY_NAME}" || true
            fi
          fi

          # Admin API Application Insights
          if az monitor app-insights component show --app "${ADMIN_AI_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            if ! terraform state list 2>/dev/null | grep -q "module.admin_api.azurerm_application_insights.admin_api"; then
              echo "Importing admin_api Application Insights..."
              terraform import 'module.admin_api.azurerm_application_insights.admin_api' \
                "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}/providers/Microsoft.Insights/components/${ADMIN_AI_NAME}" || true
            fi
          fi

          # Admin API Key Vault
          ADMIN_KV_NAME="mys-${{ env.ENVIRONMENT }}-adm-kv-${REGION_CODE}"
          if az keyvault show --name "${ADMIN_KV_NAME}" &> /dev/null; then
            if ! terraform state list 2>/dev/null | grep -q "module.admin_api.azurerm_key_vault.admin_api"; then
              echo "Importing admin_api Key Vault..."
              terraform import 'module.admin_api.azurerm_key_vault.admin_api' \
                "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}/providers/Microsoft.KeyVault/vaults/${ADMIN_KV_NAME}" || true
            fi
          fi

          # Import WAF Security Policy if it exists
          FD_PROFILE_NAME="mystira-${{ env.ENVIRONMENT }}-fd"
          WAF_POLICY_NAME="mystira-${{ env.ENVIRONMENT }}-admin-waf-security-policy"
          if az cdn security-policy show --profile-name "${FD_PROFILE_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name "${WAF_POLICY_NAME}" &> /dev/null 2>&1; then
            if ! terraform state list 2>/dev/null | grep -q 'module.front_door.azurerm_cdn_frontdoor_security_policy.admin\[0\]'; then
              echo "Importing Front Door WAF Security Policy..."
              terraform import 'module.front_door.azurerm_cdn_frontdoor_security_policy.admin[0]' \
                "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}/providers/Microsoft.Cdn/profiles/${FD_PROFILE_NAME}/securityPolicies/${WAF_POLICY_NAME}" || true
            fi
          fi

      - name: Clean Up Orphaned State
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          echo "Checking for orphaned modules in state..."

          # List of modules that were removed from codebase but may still be in state
          # NOTE: admin_api and entra_id are active modules - do NOT orphan them
          ORPHANED_MODULES=(
            "module.identity"
            "module.azure_ad_b2c"
            "module.azure-ad-b2c"
          )

          for module in "${ORPHANED_MODULES[@]}"; do
            if terraform state list 2>/dev/null | grep -q "^${module}\."; then
              echo "Found orphaned module: $module - removing from state..."
              terraform state rm "$module" || true
            fi
          done

          # Remove orphaned data sources from shared_postgresql module
          # These reference identities that no longer exist
          if terraform state list 2>/dev/null | grep -q "module.shared_postgresql.data.azurerm_user_assigned_identity"; then
            echo "Found orphaned user_assigned_identity data sources in shared_postgresql - removing..."
            for item in $(terraform state list 2>/dev/null | grep "module.shared_postgresql.data.azurerm_user_assigned_identity"); do
              terraform state rm "$item" || true
            done
          fi

      - name: Terraform Refresh (sync state with Azure)
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          terraform refresh || true
          # Remove AKS from state if it exists but not in Azure - forces recreation
          if ! az aks show --name ${{ env.AKS_CLUSTER_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "AKS not found in Azure, checking if in state..."
            if terraform state list 2>/dev/null | grep -q "azurerm_kubernetes_cluster.main"; then
              echo "Removing stale AKS from state..."
              terraform state rm azurerm_kubernetes_cluster.main
            else
              echo "AKS not in state either - will be created fresh"
            fi
          fi

      - name: Terraform Plan
        id: plan
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          set +e
          terraform plan -out=tfplan -detailed-exitcode
          PLAN_EXIT=$?
          echo "Terraform plan exit code: $PLAN_EXIT"
          if [ $PLAN_EXIT -eq 1 ]; then
            echo "Terraform plan failed"
            exit 1
          elif [ $PLAN_EXIT -eq 2 ]; then
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "Changes detected - will apply"
          else
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "No changes needed"
          fi

      - name: Upload Plan
        if: steps.plan.outputs.changes == 'true'
        uses: actions/upload-artifact@v6
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: infra/terraform/environments/${{ env.ENVIRONMENT }}/tfplan
          retention-days: 5

      - name: Check AKS Cluster (for downstream jobs)
        id: check-aks-plan
        run: |
          if az aks show --name ${{ env.AKS_CLUSTER_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster does not exist"
          fi

      - name: Plan Summary
        run: |
          echo "## Terraform Plan - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.plan.outputs.changes }}" == "true" ]; then
            echo "ðŸ“ Changes detected - will apply" >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… No changes needed" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "AKS Cluster: ${{ steps.check-aks-plan.outputs.exists == 'true' && 'âœ… Exists' || 'âŒ Not Found' }}" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Terraform Apply
  # ============================================
  apply-terraform:
    name: Apply Terraform
    runs-on: ubuntu-latest
    needs: [plan-terraform]
    if: always() && needs.plan-terraform.result == 'success'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      aks-exists: ${{ steps.check-aks-post-apply.outputs.exists }}
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Set Azure credentials for Terraform
        run: |
          ARM_CLIENT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientId')
          ARM_CLIENT_SECRET=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          ARM_SUBSCRIPTION_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
          ARM_TENANT_ID=$(echo '${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          echo "::add-mask::$ARM_CLIENT_SECRET"
          {
            echo "ARM_CLIENT_ID=$ARM_CLIENT_ID"
            echo "ARM_CLIENT_SECRET=$ARM_CLIENT_SECRET"
            echo "ARM_SUBSCRIPTION_ID=$ARM_SUBSCRIPTION_ID"
            echo "ARM_TENANT_ID=$ARM_TENANT_ID"
            echo "ARM_USE_CLI=false"
          } >> "$GITHUB_ENV"

      - name: Download Plan
        uses: actions/download-artifact@v7
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: infra/terraform/environments/${{ env.ENVIRONMENT }}

      - name: Terraform Init
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          terraform init -upgrade

      - name: Terraform Apply
        id: apply
        run: |
          cd infra/terraform/environments/${{ env.ENVIRONMENT }}
          terraform apply -auto-approve

      - name: Check AKS Cluster After Apply
        id: check-aks-post-apply
        run: |
          if az aks show --name ${{ env.AKS_CLUSTER_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster exists after Terraform apply"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::AKS Cluster not found after Terraform apply"
          fi

      - name: Apply Summary
        run: |
          echo "## Terraform Apply - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Infrastructure applied successfully" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Configure DNS Records (AKS-based)
  # ============================================
  configure-dns:
    name: Configure DNS
    runs-on: ubuntu-latest
    needs: [deploy-kubernetes]
    if: |
      always() &&
      needs.deploy-kubernetes.result == 'success' &&
      needs.deploy-kubernetes.outputs.ingress-ip != ''
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Configure DNS A Records
        run: |
          INGRESS_IP="${{ needs.deploy-kubernetes.outputs.ingress-ip }}"
          ENV_PREFIX="${{ env.ENVIRONMENT }}"
          if [ "$ENV_PREFIX" == "prod" ]; then
            ENV_PREFIX=""
          else
            ENV_PREFIX="${ENV_PREFIX}."
          fi

          echo "Configuring DNS records to point to $INGRESS_IP"

          # Configure Publisher DNS
          az network dns record-set a add-record \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --zone-name ${{ env.DNS_ZONE }} \
            --record-set-name "${ENV_PREFIX}publisher" \
            --ipv4-address "$INGRESS_IP" \
            --if-none-match || true

          # Configure Chain DNS
          az network dns record-set a add-record \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --zone-name ${{ env.DNS_ZONE }} \
            --record-set-name "${ENV_PREFIX}chain" \
            --ipv4-address "$INGRESS_IP" \
            --if-none-match || true

          # Configure API DNS
          az network dns record-set a add-record \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --zone-name ${{ env.DNS_ZONE }} \
            --record-set-name "${ENV_PREFIX}api" \
            --ipv4-address "$INGRESS_IP" \
            --if-none-match || true

          # Configure Story Generator DNS
          az network dns record-set a add-record \
            --resource-group ${{ env.DNS_ZONE_RG }} \
            --zone-name ${{ env.DNS_ZONE }} \
            --record-set-name "${ENV_PREFIX}story-generator" \
            --ipv4-address "$INGRESS_IP" \
            --if-none-match || true

          echo "::notice::DNS records configured for ${{ env.ENVIRONMENT }} pointing to $INGRESS_IP"

      - name: Check DNS Nameserver Configuration
        run: |
          echo "## DNS Nameserver Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get Azure DNS nameservers for our zone
          AZURE_NS=$(az network dns zone show --name ${{ env.DNS_ZONE }} --resource-group ${{ env.DNS_ZONE_RG }} --query "nameServers[0]" -o tsv | sed 's/\.$//')

          # Check if domain is using Azure DNS
          ACTUAL_NS=$(dig +short NS ${{ env.DNS_ZONE }} | head -1 | sed 's/\.$//')

          if echo "$ACTUAL_NS" | grep -q "azure-dns"; then
            echo "âœ… Domain is using Azure DNS nameservers" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ **Domain is NOT using Azure DNS!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The A records were created in Azure DNS, but your domain is using:" >> $GITHUB_STEP_SUMMARY
            echo "\`$ACTUAL_NS\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**To fix this, either:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Update your domain registrar's nameservers to Azure DNS:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            az network dns zone show --name ${{ env.DNS_ZONE }} --resource-group ${{ env.DNS_ZONE_RG }} --query nameServers -o tsv >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "2. Or create A records in your current DNS provider pointing to: **${{ needs.deploy-kubernetes.outputs.ingress-ip }}**" >> $GITHUB_STEP_SUMMARY
            echo "::warning::Domain ${{ env.DNS_ZONE }} is not using Azure DNS nameservers. DNS records may not resolve."
          fi

      - name: DNS Summary
        run: |
          INGRESS_IP="${{ needs.deploy-kubernetes.outputs.ingress-ip }}"
          echo "## DNS Configuration - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Load Balancer IP: $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.ENVIRONMENT }}" == "prod" ]; then
            echo "| Publisher | https://publisher.mystira.app |" >> $GITHUB_STEP_SUMMARY
            echo "| Chain | https://chain.mystira.app |" >> $GITHUB_STEP_SUMMARY
            echo "| API | https://api.mystira.app |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Publisher | https://${{ env.ENVIRONMENT }}.publisher.mystira.app |" >> $GITHUB_STEP_SUMMARY
            echo "| Chain | https://${{ env.ENVIRONMENT }}.chain.mystira.app |" >> $GITHUB_STEP_SUMMARY
            echo "| API | https://${{ env.ENVIRONMENT }}.api.mystira.app |" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================
  # Build and Push Docker Images
  # ============================================
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [apply-terraform]
    if: |
      always() &&
      (needs.apply-terraform.result == 'success' || needs.apply-terraform.result == 'skipped') &&
      (github.event.inputs.components == 'all' || github.event.inputs.components == '')
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
          token: ${{ secrets.GH_PAT }}
          persist-credentials: true

      - name: Verify submodules
        run: |
          echo "Checking submodule status..."
          git submodule status
          echo ""
          echo "Packages directory contents:"
          ls -la packages/
          echo ""
          echo "Chain package contents:"
          ls -la packages/chain/ || echo "Chain directory empty or missing"
          echo ""
          echo "Publisher package contents:"
          ls -la packages/publisher/ || echo "Publisher directory empty or missing"
          echo ""
          # Fail if submodules are empty (chain is Python, publisher is Node.js)
          if [ ! -f "packages/chain/server.py" ]; then
            echo "::error::packages/chain/server.py not found - submodule checkout failed"
            echo "Make sure GH_PAT has access to https://github.com/phoenixvc/Mystira.Chain"
            exit 1
          fi
          if [ ! -f "packages/publisher/package.json" ]; then
            echo "::error::packages/publisher/package.json not found - submodule checkout failed"
            echo "Make sure GH_PAT has access to https://github.com/phoenixvc/Mystira.Publisher"
            exit 1
          fi
          echo "âœ… Submodules verified successfully"

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and Push Publisher
        run: |
          docker build \
            -t ${{ env.ACR_NAME }}.azurecr.io/publisher:${{ env.ENVIRONMENT }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/publisher:${{ github.sha }} \
            -f infra/docker/publisher/Dockerfile \
            .
          docker push ${{ env.ACR_NAME }}.azurecr.io/publisher:${{ env.ENVIRONMENT }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/publisher:${{ github.sha }}

      - name: Build and Push Chain
        run: |
          docker build \
            -t ${{ env.ACR_NAME }}.azurecr.io/chain:${{ env.ENVIRONMENT }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/chain:${{ github.sha }} \
            -f infra/docker/chain/Dockerfile \
            .
          docker push ${{ env.ACR_NAME }}.azurecr.io/chain:${{ env.ENVIRONMENT }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/chain:${{ github.sha }}

      - name: Image Summary
        run: |
          echo "## Docker Images Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Image | Tags |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| publisher | ${{ env.ENVIRONMENT }}, ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| chain | ${{ env.ENVIRONMENT }}, ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Deploy to Kubernetes
  # ============================================
  deploy-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [apply-terraform, build-images]
    if: |
      always() &&
      (needs.apply-terraform.outputs.aks-exists == 'true') &&
      (needs.apply-terraform.result == 'success' || needs.apply-terraform.result == 'skipped') &&
      (needs.build-images.result == 'success' || needs.build-images.result == 'skipped') &&
      (github.event.inputs.components == 'all' ||
       github.event.inputs.components == 'kubernetes-only' ||
       github.event.inputs.components == 'chain' ||
       github.event.inputs.components == 'publisher' ||
       github.event.inputs.components == '')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      ingress-ip: ${{ steps.get-ingress-ip.outputs.ip }}
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.MYSTIRA_AZURE_CREDENTIALS }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Create namespace
        run: |
          kubectl create namespace mys-${{ env.ENVIRONMENT }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Enable ACR Admin
        run: |
          az acr update --name ${{ env.ACR_NAME }} --admin-enabled true --output none

      - name: Create ACR Pull Secret
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          kubectl create secret docker-registry acr-secret \
            --namespace mys-${{ env.ENVIRONMENT }} \
            --docker-server=${{ env.ACR_NAME }}.azurecr.io \
            --docker-username=$ACR_USERNAME \
            --docker-password=$ACR_PASSWORD \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy NGINX Ingress Controller
        id: get-ingress-ip
        run: |
          # Deploy NGINX Ingress Controller
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml

          # Wait for ingress controller to be ready
          echo "Waiting for NGINX Ingress Controller..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=300s || true

          # Wait for LoadBalancer IP
          echo "Waiting for LoadBalancer IP..."
          INGRESS_IP=""
          for i in {1..30}; do
            INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            if [ -n "$INGRESS_IP" ]; then
              echo "Ingress Controller IP: $INGRESS_IP"
              break
            fi
            echo "Waiting for LoadBalancer IP... ($i/30)"
            sleep 10
          done
          echo "ip=$INGRESS_IP" >> $GITHUB_OUTPUT

      - name: Deploy cert-manager
        run: |
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml || true
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s || true

      - name: Clear old TLS certificates
        run: |
          # Delete old certificate secrets so cert-manager issues fresh ones
          echo "Clearing old TLS certificates..."
          kubectl delete secret mystira-publisher-tls -n mys-${{ env.ENVIRONMENT }} --ignore-not-found
          kubectl delete secret mystira-publisher-tls-dev -n mys-${{ env.ENVIRONMENT }} --ignore-not-found
          kubectl delete secret mystira-chain-tls -n mys-${{ env.ENVIRONMENT }} --ignore-not-found
          kubectl delete secret mystira-chain-tls-dev -n mys-${{ env.ENVIRONMENT }} --ignore-not-found
          # Also delete any certificate resources so they get recreated
          kubectl delete certificate --all -n mys-${{ env.ENVIRONMENT }} --ignore-not-found || true
          echo "Old certificates cleared"

      - name: Deploy Applications
        run: |
          kubectl apply -k infra/kubernetes/overlays/${{ env.ENVIRONMENT }}

      - name: Wait for Deployments
        run: |
          echo "Waiting for deployments to be ready..."
          kubectl rollout status deployment/mys-publisher -n mys-${{ env.ENVIRONMENT }} --timeout=300s || true
          kubectl rollout status statefulset/mys-chain -n mys-${{ env.ENVIRONMENT }} --timeout=600s || true

      - name: Deployment Summary
        run: |
          echo "## Kubernetes Deployment - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pods" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n mys-${{ env.ENVIRONMENT }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Services" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get svc -n mys-${{ env.ENVIRONMENT }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Ingress" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get ingress -n mys-${{ env.ENVIRONMENT }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Final Summary
  # ============================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [validate, bootstrap, plan-terraform, apply-terraform, build-images, deploy-kubernetes, configure-dns]
    if: always()
    steps:
      - name: Final Summary
        run: |
          echo "# Deployment Summary - ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Validation | ${{ needs.validate.result == 'success' && 'âœ…' || needs.validate.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Bootstrap | ${{ needs.bootstrap.result == 'success' && 'âœ…' || needs.bootstrap.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Plan | ${{ needs.plan-terraform.result == 'success' && 'âœ…' || needs.plan-terraform.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Apply | ${{ needs.apply-terraform.result == 'success' && 'âœ…' || needs.apply-terraform.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| DNS Config | ${{ needs.configure-dns.result == 'success' && 'âœ…' || needs.configure-dns.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Images | ${{ needs.build-images.result == 'success' && 'âœ…' || needs.build-images.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy K8s | ${{ needs.deploy-kubernetes.result == 'success' && 'âœ…' || needs.deploy-kubernetes.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Environment URLs" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.ENVIRONMENT }}" == "prod" ]; then
            echo "- Publisher: https://publisher.mystira.app" >> $GITHUB_STEP_SUMMARY
            echo "- Chain: https://chain.mystira.app" >> $GITHUB_STEP_SUMMARY
            echo "- API: https://api.mystira.app" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Publisher: https://${{ env.ENVIRONMENT }}.publisher.mystira.app" >> $GITHUB_STEP_SUMMARY
            echo "- Chain: https://${{ env.ENVIRONMENT }}.chain.mystira.app" >> $GITHUB_STEP_SUMMARY
            echo "- API: https://${{ env.ENVIRONMENT }}.api.mystira.app" >> $GITHUB_STEP_SUMMARY
          fi
